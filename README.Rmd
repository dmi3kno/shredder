---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# shredder

<!-- badges: start -->
<!-- badges: end -->

The goal of shredder is to apply tidylike verbs to rstan simulation objects. The usage is similar to the `dplyr` verbs, the input is a stanfit object and the output is a manipulated stanfit object.

## Installation

You can install shredder from `GHE` with:

```{r,eval = FALSE}
remotes::install_github(
  repo = 'internal-projects/shredder',
  host = 'ghe.metrumrg.com/api/v3',
  auth_token = Sys.getenv('GHE_PAT')
)
```

## Verbs

  - Dimension
    - pars: 
      - `stan_select`   : extract specific pars
    - post-warmup samples 
      - `stan_slice`    : extract specific samples by index
      - `stan_sample_n` : extract random n samples
      - `stan_frac_n`   : extract fraction of total samples
      - `stan_filter`   : extract subset of samples conditional on filter of parameter values
      - `stan_split`    : create a list with ncut slices of the samples

## Example

This is a basic example which shows you how to solve a common problem:

```{r example}
library(shredder)
library(rstan)

objsize <- function(x) sprintf('Object Size: %s',format(object.size(x),units = 'auto'))
```

```{r}

excode <- '
  transformed data {
    real y[20];
    y[1] = 0.5796;  y[2] = 0.2276;   y[3]  = -0.2959; 
    y[4] = -0.3742; y[5] = 0.3885;   y[6]  = -2.1585;
    y[7] = 0.7111;  y[8] = 1.4424;   y[9]  = 2.5430; 
    y[10] = 0.3746; y[11] = 0.4773;  y[12] = 0.1803; 
    y[13] = 0.5215; y[14] = -1.6044; y[15] = -0.6703; 
    y[16] = 0.9459; y[17] = -0.382;  y[18] = 0.7619;
    y[19] = 0.1006; y[20] = -1.7461;
  }
  parameters {
    real mu;
    real<lower=0, upper=10> sigma;
    vector[2] z[3];
    real<lower=0> alpha;
  } 
  model {
    y ~ normal(mu, sigma);
    for (i in 1:3) 
      z[i] ~ normal(0, 1);
    alpha ~ exponential(2);
  } 
'

```

```{r,results='hide'}
fit <- stan(model_code = excode, iter = 500, verbose = FALSE)
```

```{r}
objsize(fit)

fit
```

```{r}
fit1 <- fit%>%
  stan_select(mu)

objsize(fit1)

fit1

fit2 <- fit%>%
  stan_select(mu,sigma)

objsize(fit2)

fit2

fit3 <- fit%>%
  stan_select(!!!rlang::syms(c('z','alpha')))

objsize(fit3)

fit3

```

```{r}

  fit4 <- fit%>%
    stan_slice(1:50,inc_warmup = TRUE)

  objsize(fit4)

  fit4

  fit5 <- fit%>%
    stan_slice(1:50,inc_warmup = FALSE)

  objsize(fit5)
  
  fit5
  
  fit6 <- fit%>%
    stan_sample_n(100)

  objsize(fit6)
  
  fit6
  
  fit7 <- fit%>%
    stan_sample_frac(0.5)
  
  objsize(fit7)
  
  fit7
```

```{r}
  fit8 <- fit%>%
    stan_select(mu)%>%
    stan_slice(1:50)

  fit8
```

```{r}

fit9 <- fit%>%
    stan_split(inc_warmup = TRUE)

length(fit9)

purrr::map_chr(fit9,objsize)

fit9[[1]]

fit10 <- fit%>%
    stan_split(inc_warmup = FALSE)

purrr::map_chr(fit10,objsize)

fit10[[1]]

fit11 <- fit%>%
    stan_split(ncut = 4, inc_warmup = FALSE)

length(fit11)

purrr::map_chr(fit11,objsize)

fit11[[1]]

```